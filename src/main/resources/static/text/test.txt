It feels so gratifying to finally be able to post something on here after working on this project.

[p] <h,SQLite Bank Statement Conversion Project>

[p]<v,6> Over the past year or so, I've dedicated myself to upskilling in software development.
         Around June/July 2023 I started working on a simple project to
         convert my downloaded Nationwide files into a readable excel format {Link here to GitHub}.
         This was a command line program used to read bank statement files, downloaded from online banking sites,
         which are then formatted into an SQLite DB. These SQLite DB's could then be exported into a formatted Excel File within the program.

[p] <r,7>While this project did not seem complicated at the outset, it marked a departure from the type of coding projects/ assignments I had previously worked on.
    With University assignments, I was only required to build programs or models for specific scripted challenges.
    In contrast this conversion app demanded a deeper understanding of software architecture than I had previously needed.
    I set out to craft a codebase characterized by modularity and extensibility.
    One way I hoped to do this was by follow architecture principles such as the SOLID principles {Link to an article on solid principles}.
    Working on this project was the first time I interacted with any build tools (I used maven for that project), handled proper logging systems (log4j here),
    and tried to constantly work with test based development. I found it incredibly rewarding whenever I experienced the tangible benefits of
    thoughtful planning and foresight in my code.

[p] <c,
	/*
	 * =========== ABSTRACT IMPLEMENTATION ============
	 */
	/**
	 * Creates the Inbound table in the database. The table will be created only if
	 * it does not already exist. The table schema includes columns for ID, Date,
	 * trType, RawDescription, ProcessDescription, Category, Paid_In, and Balance.
	 */

	public void createTable() {
		String addTable = "CREATE TABLE IF NOT EXISTS " + getTableName() + " (\n" + "ID text PRIMARY KEY, \n"
				+ "Date text NOT NULL, \n" + "trType text, \n" + "RawDescription text NOT NULL, \n"
				+ "ProcessDescription text NOT NULL, \n" + "Category text NOT NULL, \n" + "Paid_In REAL NOT NULL,"
				+ "Balance REAL NOT NULL);";

		try (Connection conn = DriverManager.getConnection(getDB().getUrl()); Statement stmt = conn.createStatement()) {
			stmt.execute(addTable);
			String log = String.format("Created Table: %s", getTableName());
			logger.info(log);
		} catch (SQLException e) {
			String log = String.format("Failed to create table: %s. %s", getTableName(), e.getMessage());
			logger.error(log);
		}
	}
>However, I did receive feedback from my friends, who suggested that I might have been overly fixated on certain principles, particularly the Single Responsibility Principle (SRP).
        They suggested my code base was beginning to get overly fragmented with a multitude of small, specialised classes each with only one responsibility.
        With my handling of my "Table" class objects, I could have found more commonality between classes.
        Within my database, I had distinct tables for Inbound and Outbound transactions, each represented by separate class objects (TableInbound and TableOutbound) that extended an abstract class, Table.
        Additionally, I had separate reader and writer classes for each variation of the table class (e.g., TableInboundReader, TableOutboundReader).
        While my intention was to facilitate easier updates and extensions, I realized that this approach led to unnecessary repetition and complexity.
        Both table classes essentially shared the same structure and functionality.
        It did not really affect my ability to develop for that project - but I think the point made from my friends was that I need to actively think more about the type of structure I'm making
        rather than following convention for the sake of convention.

[p] On a similar note, one of the biggest things I learnt from working on this project was the importance of establishing your initial requirements.
    My typical approach involves figuring out my requirements/resolving issues as I complete the project. This is a good approach for my personal projects,
    since it usually prevents me from getting bogged down and procrastinating.
    The main drawback of this approach is the need for subsequent refactoring when essential features are overlooked during the initial design phase.
    Since the projects I work on are for personal development only, I have a degree of flexibility that allows for trial and error.
    But I can still appreciate the critical role of establishing clear project requirements, particularly in professional environments.

[p] I started working on this website around February 2024.
    I wanted to create a user-friendly website for publishing my own articles and blog posts.
    Leveraging the power of Spring Boot for the backend and Vaadin for the frontend, I wanted to develop a robust and scalable web application
    that I could easily update and use.
    This web app project felt like the next stage of development from the simple java command line conversion app project I made before,
     as a full stack project which relies on database integration.

[p] <c,

public interface VisualSourceRepository extends JpaRepository VisualSource, Long {

    public Optional VisualSource findByImagePath(String imagePath);

    public VisualSource save(VisualSource visualSource);
}
>
Spring Boot proved to be a game-changer for this site's development. I had dabbled with Springboot before, but all of my
other projects that I had brought to completion had been done without a major framework like Springboot to handle architectural heavy lifting.
Springboot's integration with Spring JPA was one of the things I was the most grateful for. Leveraging Spring Data JPA,
I was able to streamline data access operations, eliminating the need for manual JDBC SQL queries and database calls that I had used in my
previous bank statement conversion project. This both reduced development time and improved my codes quality significantly.
I could interact with the database layer in a more intuitive and efficient manner.

[p] <l,8>
I used Vaadin for the front end of this site. While I think highly of Vaadin's capabilities, I sometimes wonder whether I should
have bit the bullet and created the front end entirely in JavaScript, since Vaadin is far more niche than using JavaScript for front end development.
For now it doesn't really matter, I can even switch over to writing some sections of this site in a JavaScript framework at some point if it is helpful.

Having never worked on any web development related projects, there was a somewhat steep learning curve at some points. Once I decided
to have a secure api I could use to update the contents of the site while the page was live, I had to develop some understanding of web security.
Spring Security is a helpful spring integration that made this process much easier. It can offer a basic level of security including authentication, authorization
and protection from some security attacks such as CSRF and XSS right out of the box. Most helpful for securing my api's was its ease of adding
multiple authentication filters to your application's security chain, such as form-based authentication and token based authentication. Vaadin does
integrate somewhat well with spring security, allowing you to easily customise a front end login page.

[p]
<v,56>
The schemas of my database were much more complicated for this project. Storing web page article information and then loading
said article into a template while including unique article formatting was a complicated task.
I wanted to allow for rich text potential, and easy inclusion of multiple kinds of visual sources such as images, gifs, youtube links etc.
I intend to write an article on how I handled my approach to this in the future. In the end I managed to build a system that I believe is both maintainable and extensible.

One of the hardest things that I am still working on is balancing aesthetics with functionality across various devices. In particular, I do struggle
with considerations of CSS media queries and flexible layout techniques.  While Vaadin's FlexLayout offered some assistance,
I ultimately opted to rely more on HTML and CSS for layout customization toward the end of the project.

[p]

Looking ahead, I'm excited about the future possibilities for this site now that it is up and running, and I plan to continue refining
its features. My next area of focus is enabling users to comment. My security authentication system is setup in a way that should be extensible
for user profiles and authentication, I just want to better refine the necessary features and requirements of this system before implementing it.

Unlike the structured environment of academic studies where problem specifications are predefined, developing projects like these required me to define my own specifications and solve problems organically.
It was frustrating; when I would encounter problems with no-ready made solutions that can be found online through stack overflow, and bots like chatgpt or Claude 3 could not help me.
These instances forced me to better understand the frameworks and libraries I was using, and when I eventually was able to
resolve these issues it felt infinitely more satisfying.
Forcing myself to delve into projects where I initially had little to no understanding I think was incredibly helpful.
I am quite a proud person, and I can suffer from a fear of producing subpar work as well as imposter sydrome.
Because of this it's essential for me to push through that apprehension and produce something.
It's inevitable to encounter challenges and write less-than-ideal code along the way, but I can confidently say the code I write for this
website is better than the code I produced for my bank statement conversion app. It sounds cliché but it is a learning opportunity that ultimately contributes to my improvement.
Over time I am sure I will recognise the flaws and quirks of this website's code base, and it might undergo numerous transformations because of that.
 But that I think that is the nature of getting better at a skill—it's a journey of perpetual refinement and evolution
